-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ORM
--   
--   ORM library for PostgreSQL
@package orville
@version 0.8.3.0


module Database.Orville.PostgresSQL

-- | <a>createConnectionPool</a> allocates a pool of connections to a
--   PosgreSQL server. The returned pool can be used as the endpoint to
--   <a>newOrvilleEnv</a> to construct.
createConnectionPool :: Int -> NominalDiffTime -> Int -> String -> IO (Pool Connection)
data Pool a :: * -> *
data Connection :: *


module Database.Orville.Select
data Select row
selectQuery :: FromSql row -> FromClause -> SelectOptions -> Select row
selectQueryTable :: TableDefinition readEntity writeEntity key -> SelectOptions -> Select readEntity
selectQueryRows :: [SelectExpr] -> FromClause -> SelectOptions -> Select [(String, SqlValue)]
selectQueryRaw :: FromSql row -> String -> [SqlValue] -> Select row
selectQueryRawRows :: String -> [SqlValue] -> Select [(String, SqlValue)]
selectQueryColumns :: [SelectExpr] -> FromSql row -> FromClause -> SelectOptions -> Select row
selectField :: FieldDefinition a -> SelectForm
data FromClause
fromClauseRaw :: String -> FromClause
fromClauseTableName :: String -> FromClause
fromClauseTable :: TableDefinition readEntity writeEntity key -> FromClause
runSelect :: MonadOrville conn m => Select row -> m [row]


module Database.Orville.Raw
selectSql :: MonadOrville conn m => String -> [SqlValue] -> FromSql result -> m [result]
selectSqlRows :: MonadOrville conn m => String -> [SqlValue] -> m ResultSet
decodeSqlRows :: MonadOrville conn m => FromSql result -> ResultSet -> m [result]
type ResultSet = [[(String, SqlValue)]]
updateSql :: MonadOrville conn m => String -> [SqlValue] -> m Integer
withConnection :: MonadOrville conn m => (conn -> m a) -> m a
withTransaction :: MonadOrville conn m => m a -> m a


module Database.Orville.Expr
data RawExpr
rawSql :: String -> RawExpr
class GenerateSql expr
generateSql :: GenerateSql expr => expr -> RawExpr
data Expr a
rawSqlExpr :: String -> Expr a
expr :: a -> Expr a
type NameExpr = Expr NameForm
data NameForm
unescapedName :: NameForm -> String
type SelectExpr = Expr SelectForm
data SelectForm
SelectForm :: NameForm -> Maybe NameForm -> SelectForm
[selectFormColumn] :: SelectForm -> NameForm
[selectFormAlias] :: SelectForm -> Maybe NameForm
selectColumn :: NameForm -> SelectForm
qualified :: QualifySql form => form -> String -> form
aliased :: SelectForm -> NameForm -> SelectForm


module Database.Orville.Conduit
selectConduit :: (Monad m, MonadOrville conn m, MonadCatch m) => Select row -> Source m row


module Database.Orville.Core

-- | A <a>TableDefinition</a> is the center of the Orville universe. A
--   <a>TableDefinition</a> defines the structure of a table in the
--   database and associates it with a Haskell datatype, usually a Haskell
--   record type. The <a>TableDefinition</a> must specify how the Haskell
--   type is converted to and from the database schema, as as well as
--   provide same basic utility functions required by Orville for
--   interacting with the Haskell datatype.
--   
--   Usually you will use <tt>TableParams</tt> to construct a
--   <a>TableDefinition</a> in a more concise way. This type is provided as
--   an escape hatch for any situations where <tt>TableParams</tt> is too
--   restrictive for the sql mapping required by a type.
data TableDefinition readEntity writeEntity key
TableDefinition :: String -> [SomeField] -> [String] -> FieldDefinition key -> FromSql readEntity -> ToSql writeEntity () -> (readEntity -> key) -> TableComments () -> TableDefinition readEntity writeEntity key

-- | The name of the table in the database.
[tableName] :: TableDefinition readEntity writeEntity key -> String

-- | A list of field definitions defining the table structure
[tableFields] :: TableDefinition readEntity writeEntity key -> [SomeField]

-- | A list of any columns that may be deleted from the table by Orville.
--   (Orville will never delete a column without being told it is safe)
[tableSafeToDelete] :: TableDefinition readEntity writeEntity key -> [String]

-- | The statically typed field definition that is the primary key.
--   Currently this field must still by listed in <a>tableFields</a>
[tablePrimaryKey] :: TableDefinition readEntity writeEntity key -> FieldDefinition key

-- | A definition of how to convert the haskell type from a sql row
[tableFromSql] :: TableDefinition readEntity writeEntity key -> FromSql readEntity

-- | A function to set the key on the entity
[tableToSql] :: TableDefinition readEntity writeEntity key -> ToSql writeEntity ()

-- | A function to get the key on the entity
[tableGetKey] :: TableDefinition readEntity writeEntity key -> readEntity -> key

-- | Any comments that might be interesting for developers to see. These
--   comments will get printed in the log if there is an erro while
--   attempting to migrate the table.
[tableComments] :: TableDefinition readEntity writeEntity key -> TableComments ()

-- | <a>mkTableDefinition</a> converts a <a>TableParams</a> to
--   <a>TableDefinition</a>. Usually this is used directly on a record
--   literal of the <a>TableParams</a>. For example:
--   
--   <pre>
--   data Foo key = Foo key { fooId :: Record }
--   myTable :: TableDefinition Foo
--   myTable = mkTableDefinition $
--     TableParams
--       { tblName = "foo"
--       , tblMapper = User <a>$</a> attrField fooId idField
--       , tableSafeToDelete = []
--       , tblSetKey = key foo -&gt; foo { fooId = key }
--       , tblGetKey = fooId
--       , tblComments = []
--       }
--   </pre>
mkTableDefinition :: TableParams readEntity writeEntity key -> TableDefinition readEntity writeEntity key
tableKeyToSql :: TableDefinition readEntity writeEntity key -> key -> SqlValue
tableKeyFromSql :: TableDefinition readEntity writeEntity key -> SqlValue -> Maybe key

-- | SqlType defines the mapping of a Haskell type (<tt>a</tt>) to a SQL
--   column type in the database. This includes both how to convert the
--   type to and from the raw values read from the database as well as the
--   schema information required to create and migrate columns using the
--   type.
data SqlType a
SqlType :: String -> Maybe String -> Bool -> SqlTypeId -> Maybe Int -> (a -> SqlValue) -> (SqlValue -> Maybe a) -> SqlType a

-- | The raw SQL DDL to use when creating/migrating columns of this type
--   (not including any NULL or NOT NULL declarations)
[sqlTypeDDL] :: SqlType a -> String

-- | The raw SQL DDL to use when creating/migrating columns with foreign
--   keys to this type. This is used foreignRefType to build a new SqlType
--   when making foreign key fields
[sqlTypeReferenceDDL] :: SqlType a -> Maybe String

-- | Indicates whether columns should be marked NULL or NOT NULL in the
--   database schema. If this is <a>True</a>, then <a>sqlTypeFromSql</a>
--   should provide a handling of <tt>SqlNull</tt> that returns an
--   <tt>a</tt>, not <a>Nothing</a>.
[sqlTypeNullable] :: SqlType a -> Bool

-- | <a>sqlTypeId</a> will be compared to the <tt>colType</tt> field found
--   in the <a>SqlColDesc</a> return by <tt>describeTable</tt> when
--   determining whether a column type change is required when migrating
--   the database.
[sqlTypeId] :: SqlType a -> SqlTypeId

-- | 'sqlTypeSqlSize will be compared to the <tt>colSize</tt> field found
--   in the <a>SqlColDesc</a> return by <tt>describeTable</tt> when
--   determining whether a column type change is required when migrating
--   the database.
[sqlTypeSqlSize] :: SqlType a -> Maybe Int

-- | A function for converting Haskell values of this type into values to
--   be stored in the database.
[sqlTypeToSql] :: SqlType a -> a -> SqlValue

-- | A function for converting values of this are stored in the database
--   into Haskell values. This function should return <a>Nothing</a> to
--   indicate an error if the conversion is impossible. Otherwise it should
--   return <a>Just</a> the corresponding <tt>a</tt> value.
[sqlTypeFromSql] :: SqlType a -> SqlValue -> Maybe a

-- | <a>serial</a> defines a 32-bit auto-incrementing column type. This
--   corresponds to the <a>SERIAL</a> type in PostgresSQL.
serial :: SqlType Int32

-- | <a>serial</a> defines a 64-bit auto-incrementing column type. This
--   corresponds to the <a>BIGSERIAL</a> type in PostgresSQL.
bigserial :: SqlType Int64

-- | <a>text</a> defines a fixed length text field type. This corresponds
--   to a "CHAR(len)" type in SQL.
text :: Int -> SqlType Text

-- | <a>varText</a> defines a variable text field type with a max length.
--   This corresponds to a "VARCHAR(len)" type in SQL.
varText :: Int -> SqlType Text

-- | <a>integer</a> defines a 32-bit integer type. This corresponds to the
--   <a>INTEGER</a> type in SQL.
integer :: SqlType Int32

-- | <a>bigInteger</a> defines a 64-bit integer type. This corresponds to
--   the <a>BIGINT</a> type in SQL.
bigInteger :: SqlType Int64

-- | <a>double</a> defines a floating point numeric type. This corresponds
--   to the "DOUBLE PRECISION" type in SQL.
double :: SqlType Double

-- | <a>boolean</a> defines a True/False boolean type. This corresponds to
--   the <a>BOOLEAN</a> type in SQL.
boolean :: SqlType Bool

-- | <a>date</a> defines a type representing a calendar date (without time
--   zone). It corresponds to the <a>DATE</a> type in SQL.
date :: SqlType Day

-- | <a>timestamp</a> defines a type representing a particular point in
--   time (without time zone). It corresponds to the "TIMESTAMP with time
--   zone" type in SQL.
--   
--   Note: This is NOT a typo. The "TIMESTAMP with time zone" type in SQL
--   does not include any actual time zone information. For an excellent
--   explanation of the complexities involving this type, please see Chris
--   Clark's blog post about it:
--   <a>http://blog.untrod.com/2016/08/actually-understanding-timezones-in-postgresql.html</a>
timestamp :: SqlType UTCTime

-- | <a>textSearchVector</a> defines a type for indexed text searching. It
--   corresponds to the <a>TSVECTOR</a> type in PostgresSQL.
textSearchVector :: SqlType Text

-- | <a>convertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> in the same manner as <a>maybeConvertSqlType</a> in
--   cases where an <tt>a</tt> can always be converted to a <tt>b</tt>.
convertSqlType :: (b -> a) -> (a -> b) -> SqlType a -> SqlType b

-- | <a>maybeConvertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> which changing the column type that will be used in the
--   database schema. The functions given will be used to convert the now
--   Haskell type to and from the original type when reading and writing
--   values from the database. When reading an <tt>a</tt> value from the
--   database, the conversion function should produce <a>Nothing</a> if the
--   value cannot be successfully converted to a <tt>b</tt>
maybeConvertSqlType :: (b -> a) -> (a -> Maybe b) -> SqlType a -> SqlType b

-- | <a>nullableType</a> creates a nullable version of an existing
--   <a>SqlType</a>. The underlying sql type will be the same as the
--   original, but column will be created with a <tt>NULL</tt> constraint
--   instead a 'NOT NULL' constraint. The Haskell value <a>Nothing</a> will
--   be used represent NULL values when converting to and from sql.
nullableType :: SqlType a -> SqlType (Maybe a)

-- | <a>TableParams</a> is the simplest way to make a
--   <a>TableDefinition</a>. You can use <a>mkTableDefinition</a> to make a
--   definition from the simplified params. Where <a>TableDefinition</a>
--   requires the <a>tableFields</a>, <a>tableFromSql</a>, and
--   <a>tableToSql</a> to all be defined separately and kept in sync,
--   <a>TableParams</a> provides a single <a>tblMapper</a> field that
--   specifies all three simultaneously and ensures they are consistent
--   with one another.
data TableParams readEntity writeEntity key
TableParams :: String -> RelationalMap writeEntity readEntity -> [String] -> FieldDefinition key -> (readEntity -> key) -> TableComments () -> TableParams readEntity writeEntity key

-- | The name of the table in the database
[tblName] :: TableParams readEntity writeEntity key -> String

-- | The relational mapping that defines how the Haskell entity type is
--   converted both to and from sql. The fields utilized in the mapping are
--   used to automatically build the list of <tt>FieldDefinitions</tt> that
--   define the structure of the table in the database.
[tblMapper] :: TableParams readEntity writeEntity key -> RelationalMap writeEntity readEntity

-- | A list of any columns that may be deleted from the table by Orville.
--   (Orville will never delete a column without being told it is safe)
[tblSafeToDelete] :: TableParams readEntity writeEntity key -> [String]

-- | A function to set the key on the entity
[tblPrimaryKey] :: TableParams readEntity writeEntity key -> FieldDefinition key

-- | A function to get the key on the entity
[tblGetKey] :: TableParams readEntity writeEntity key -> readEntity -> key

-- | Any comments that might be interesting for developers to see. These
--   comments will get printed in the log if there is an erro while
--   attempting to migrate the table.
[tblComments] :: TableParams readEntity writeEntity key -> TableComments ()
data RelationalMap a b
mapAttr :: (a -> b) -> RelationalMap b c -> RelationalMap a c
mapField :: FieldDefinition a -> RelationalMap a a
attrField :: (a -> b) -> FieldDefinition b -> RelationalMap a b
maybeMapper :: RelationalMap a b -> RelationalMap (Maybe a) (Maybe b)
prefixMap :: String -> RelationalMap a b -> RelationalMap a b
partialMap :: RelationalMap a (Either String a) -> RelationalMap a a
readOnlyMap :: RelationalMap a b -> RelationalMap c b
readOnlyField :: FieldDefinition a -> RelationalMap b a

-- | <a>OrvilleEnv</a> tracks all the environment information required for
--   an 'OrvilleT conn m' Monad to operate. Use <a>newOrvilleEnv</a> to
--   construct one.
data OrvilleEnv conn

-- | <a>newOrvilleEnv</a> initialized an <a>OrvilleEnv</a> for service. The
--   connection pool provided will be used to obtain connections to the
--   database ase required. You can use the <a>createConnectionPool</a>
--   utility function to create a connection pool to a PosgreSQL server.
newOrvilleEnv :: Pool conn -> OrvilleEnv conn
setStartTransactionSQL :: String -> OrvilleEnv conn -> OrvilleEnv conn
aroundRunningQuery :: (forall a. QueryType -> String -> IO a -> IO a) -> OrvilleEnv conn -> OrvilleEnv conn
addTransactionCallBack :: (TransactionEvent -> IO ()) -> OrvilleEnv conn -> OrvilleEnv conn
ormEnvPool :: OrvilleEnv conn -> Pool conn
data TransactionEvent
TransactionStart :: TransactionEvent
TransactionCommit :: TransactionEvent
TransactionRollback :: TransactionEvent
data OrvilleT conn m a
unOrvilleT :: OrvilleT conn m a -> ReaderT (OrvilleEnv conn) m a
data SqlValue :: *
class (Monad m, MonadIO m, IConnection conn, MonadBaseControl IO m, MonadThrow m) => MonadOrville conn m | m -> conn
getOrvilleEnv :: MonadOrville conn m => m (OrvilleEnv conn)
localOrvilleEnv :: MonadOrville conn m => (OrvilleEnv conn -> OrvilleEnv conn) -> m a -> m a
runOrville :: OrvilleT conn m a -> OrvilleEnv conn -> m a
mapOrvilleT :: Monad n => (m a -> n b) -> OrvilleT conn m a -> OrvilleT conn n b
data QueryType
SelectQuery :: QueryType
InsertQuery :: QueryType
UpdateQuery :: QueryType
DeleteQuery :: QueryType
DDLQuery :: QueryType
withTransaction :: MonadOrville conn m => m a -> m a
data ColumnFlag
PrimaryKey :: ColumnFlag
Default :: a -> ColumnFlag
Unique :: ColumnFlag
References :: (TableDefinition readEntity writeEntity key) -> (FieldDefinition key) -> ColumnFlag
ColumnDescription :: String -> ColumnFlag
AssignedByDatabase :: ColumnFlag
data Now
Now :: Now
data ColumnType
AutomaticId :: ColumnType
ForeignId :: ColumnType
Text :: Int -> ColumnType
VarText :: Int -> ColumnType
Date :: ColumnType
Timestamp :: ColumnType
Integer :: ColumnType
BigInteger :: ColumnType
TextSearchVector :: ColumnType
Double :: ColumnType
Boolean :: ColumnType
data FieldDefinition a
fieldOfType :: SqlType a -> String -> FieldDefinition a
textField :: String -> Int -> FieldDefinition Text
fixedTextField :: String -> Int -> FieldDefinition Text
dayField :: String -> FieldDefinition Day
utcTimeField :: String -> FieldDefinition UTCTime
int32Field :: String -> FieldDefinition Int32
int64Field :: String -> FieldDefinition Int64
doubleField :: String -> FieldDefinition Double
boolField :: String -> FieldDefinition Bool
automaticIdField :: String -> FieldDefinition Int32
searchVectorField :: String -> FieldDefinition Text
nullableField :: FieldDefinition a -> FieldDefinition (Maybe a)
foreignKeyField :: String -> TableDefinition readEntity writeEntity key -> FieldDefinition key -> FieldDefinition key
withFlag :: FieldDefinition a -> ColumnFlag -> FieldDefinition a
withName :: FieldDefinition a -> String -> FieldDefinition a
withConversion :: FieldDefinition a -> (SqlType a -> SqlType b) -> FieldDefinition b
fieldFromSql :: FieldDefinition a -> FromSql a
fieldToSqlValue :: FieldDefinition a -> a -> SqlValue
data SomeField
SomeField :: (FieldDefinition a) -> SomeField
withPrefix :: FieldDefinition a -> String -> FieldDefinition a
fieldName :: FieldDefinition a -> String
fieldType :: FieldDefinition a -> SqlType a
fieldFlags :: FieldDefinition a -> [ColumnFlag]
data IndexDefinition
IndexDefinition :: String -> Bool -> String -> String -> IndexDefinition
[indexName] :: IndexDefinition -> String
[indexUnique] :: IndexDefinition -> Bool
[indexTable] :: IndexDefinition -> String
[indexBody] :: IndexDefinition -> String
uniqueIndex :: String -> TableDefinition readEntity writeEntity key -> [SomeField] -> IndexDefinition
simpleIndex :: String -> TableDefinition readEntity writeEntity key -> [SomeField] -> IndexDefinition
data ConstraintDefinition
ConstraintDefinition :: String -> String -> String -> ConstraintDefinition
[constraintName] :: ConstraintDefinition -> String
[constraintTable] :: ConstraintDefinition -> String
[constraintBody] :: ConstraintDefinition -> String
uniqueConstraint :: String -> TableDefinition readEntity writeEntity key -> [SomeField] -> ConstraintDefinition
dropConstraint :: TableDefinition readEntity writeEntity key -> String -> SchemaItem
data FromSql a
data FromSqlError
RowDataError :: String -> FromSqlError
QueryError :: String -> FromSqlError
class ColumnSpecifier col
selectForm :: ColumnSpecifier col => col -> SelectForm
col :: (ColumnSpecifier col, Convertible SqlValue a) => col -> FromSql a
data ToSql a b
getField :: Convertible a SqlValue => (entity -> a) -> ToSql entity ()
getComponent :: (entity -> a) -> ToSql a () -> ToSql entity ()
data SchemaItem
Table :: (TableDefinition readEntity writeEntity key) -> SchemaItem
DropTable :: String -> SchemaItem
Index :: IndexDefinition -> SchemaItem
DropIndex :: String -> SchemaItem
Constraint :: ConstraintDefinition -> SchemaItem
DropConstraint :: String -> String -> SchemaItem
type SchemaDefinition = [SchemaItem]
type Record = Int
type CreatedAt = UTCTime
type UpdatedAt = UTCTime
type OccurredAt = UTCTime
data TableComments a
noComments :: TableComments ()
say :: String -> (Int, Int, Int) -> String -> TableComments ()
data WhereCondition
whereAnd :: [WhereCondition] -> WhereCondition
whereOr :: [WhereCondition] -> WhereCondition
whereIn :: FieldDefinition a -> [a] -> WhereCondition
whereLike :: FieldDefinition a -> String -> WhereCondition
whereLikeInsensitive :: FieldDefinition a -> String -> WhereCondition
whereNotIn :: FieldDefinition a -> [a] -> WhereCondition
whereQualified :: TableDefinition a b c -> WhereCondition -> WhereCondition
whereRaw :: String -> [SqlValue] -> WhereCondition
isNull :: FieldDefinition a -> WhereCondition
isNotNull :: FieldDefinition a -> WhereCondition
(.==) :: FieldDefinition a -> a -> WhereCondition
(.<>) :: FieldDefinition a -> a -> WhereCondition
(.<-) :: FieldDefinition a -> [a] -> WhereCondition
(%==) :: FieldDefinition a -> a -> WhereCondition
(.>) :: FieldDefinition a -> a -> WhereCondition
(.>=) :: FieldDefinition a -> a -> WhereCondition
(.<) :: FieldDefinition a -> a -> WhereCondition
(.<=) :: FieldDefinition a -> a -> WhereCondition
data SelectOptions
SelectOptions :: First Bool -> [WhereCondition] -> [OrderByClause] -> First Int -> First Int -> [GroupByClause] -> SelectOptions
[selectDistinct] :: SelectOptions -> First Bool
[selectOptWhere] :: SelectOptions -> [WhereCondition]
[selectOptOrder] :: SelectOptions -> [OrderByClause]
[selectOptLimit] :: SelectOptions -> First Int
[selectOptOffset] :: SelectOptions -> First Int
[selectOptGroup] :: SelectOptions -> [GroupByClause]
where_ :: WhereCondition -> SelectOptions
distinct :: SelectOptions
order :: ToOrderBy a => a -> SortDirection -> SelectOptions
limit :: Int -> SelectOptions
offset :: Int -> SelectOptions
groupBy :: ToGroupBy a => a -> SelectOptions

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m
infixr 6 <>
data FieldUpdate
fieldUpdate :: FieldDefinition a -> a -> FieldUpdate
(.:=) :: FieldDefinition a -> a -> FieldUpdate
data OrderByClause
OrderByClause :: String -> [SqlValue] -> SortDirection -> OrderByClause
data SortDirection
Ascending :: SortDirection
Descending :: SortDirection

-- | migrateSchema will attempt to make changes to the actual database
--   schema that it it matches the provided SchemaDefinition. Unsafe
--   migrations such as dropping tables or columns are never attempted
--   unless the SchemaDefinition explicitly states that the items are safe
--   to drop. Column types may be changed, but will fail if the database
--   cannot successfully make the request type change.
migrateSchema :: MonadOrville conn m => SchemaDefinition -> m ()
data MigrationError
MigrationLockExcessiveRetryError :: String -> MigrationError
MigrationExecutionError :: SchemaItem -> SomeException -> MigrationError

-- | generateMigrationPlan inspects the state of the actual database schema
--   and constructs a plan describing what changes would be made to make it
--   match the provided SchemaDefinition. If the actual schema already
--   matches the definition, Nothing will be returned.
generateMigrationPlan :: MonadOrville conn m => SchemaDefinition -> m (Maybe MigrationPlan)
data MigrationPlan
data MigrationItem
MigrationItem :: SchemaItem -> DDL -> MigrationItem
[migrationItemSchemaItem] :: MigrationItem -> SchemaItem
[migrationItemDDL] :: MigrationItem -> DDL
migrationPlanItems :: MigrationPlan -> [MigrationItem]
selectAll :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> SelectOptions -> m [readEntity]
selectFirst :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> SelectOptions -> m (Maybe readEntity)
deleteRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> key -> m ()
deleteWhere :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> [WhereCondition] -> m Integer
findRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> key -> m (Maybe readEntity)
findRecords :: (Ord key, MonadOrville conn m) => TableDefinition readEntity writeEntity key -> [key] -> m (Map key readEntity)
findRecordsBy :: (Ord fieldValue, MonadOrville conn m) => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> m (Map fieldValue [readEntity])
insertRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> writeEntity -> m readEntity
insertRecordMany :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> [writeEntity] -> m ()
updateFields :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> [FieldUpdate] -> [WhereCondition] -> m Integer
updateRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> key -> writeEntity -> m ()


module Database.Orville.Popper
data PopError
MissingRecord :: (TableDefinition readEntity writeEntity key) -> (FieldDefinition fieldValue) -> fieldValue -> PopError
Unpoppable :: String -> PopError
data Popper a b
data Popped a
PoppedValue :: a -> Popped a
PoppedError :: PopError -> Popped a

-- | Left-to-right composition
(>>>) :: Category k cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition
(<<<) :: Category k cat => cat b c -> cat a b -> cat a c
infixr 1 <<<
abortPop :: PopError -> Popper a b
certainly :: PopError -> Popper (Maybe b) b
certainly' :: Popper a PopError -> Popper a (Maybe b) -> Popper a b
fromKern :: (a -> b) -> Popper a b
hasMany :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue [readEntity]
hasManyIn :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper [fieldValue] (Map fieldValue [readEntity])
hasOneIn :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper [fieldValue] (Map fieldValue readEntity)
hasManyInWhere :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> Popper [fieldValue] (Map fieldValue [readEntity])
hasManyWhere :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> Popper fieldValue [readEntity]
hasOne :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue (Maybe readEntity)
hasOne' :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue readEntity
hasOneWhere :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> Popper fieldValue (Maybe readEntity)
kern :: Popper a a
missingRecordMessage :: TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> fieldValue -> String
popMissingRecord :: TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue PopError
onKern :: (a -> b -> c) -> Popper b a -> Popper b c
pop :: MonadOrville conn m => Popper a b -> a -> m (Popped b)
popThrow :: MonadOrville conn m => Popper a b -> a -> m b
popFirst :: TableDefinition readEntity writeEntity key -> SelectOptions -> Popper a (Maybe readEntity)
popMany :: Popper a b -> Popper [a] [b]
onPopMany :: Popper a b -> Popper [a] [b] -> Popper a b
popMaybe :: Popper a b -> Popper (Maybe a) (Maybe b)

-- | popQuery embeds an Orville operation in a popper. It is left up to the
--   programmer to ensure that the Orville operation does not do any
--   updates to the database, but only does queries.
--   
--   The initial string argument is a description of the query to put into
--   the results of <a>explain</a>
popQuery :: String -> (forall conn m. MonadOrville conn m => m b) -> Popper a b
popRecord :: TableDefinition readEntity writeEntity key -> key -> Popper a (Maybe readEntity)
popRecord' :: TableDefinition readEntity writeEntity key -> key -> Popper a readEntity
popTable :: TableDefinition readEntity writeEntity key -> SelectOptions -> Popper a [readEntity]
explain :: Popper a b -> String
explainLines :: Popper a b -> [String]
instance GHC.Show.Show Database.Orville.Popper.PopError
instance GHC.Exception.Exception Database.Orville.Popper.PopError
instance GHC.Base.Functor Database.Orville.Popper.Popped
instance GHC.Base.Applicative Database.Orville.Popper.Popped
instance GHC.Base.Functor (Database.Orville.Popper.Popper a)
instance GHC.Base.Applicative (Database.Orville.Popper.Popper a)
instance Control.Category.Category Database.Orville.Popper.Popper
instance Control.Arrow.Arrow Database.Orville.Popper.Popper
instance Control.Arrow.ArrowChoice Database.Orville.Popper.Popper


module Database.Orville

module Database.Orville.Trigger
insertTriggered :: (MonadThrow m, MonadOrville conn m, MonadTrigger trigger m, InsertTrigger trigger readEntity) => TableDefinition readEntity writeEntity key -> writeEntity -> m readEntity
class InsertTrigger trigger readEntity
insertTriggers :: InsertTrigger trigger readEntity => readEntity -> [trigger]
updateTriggered :: (MonadThrow m, MonadOrville conn m, MonadTrigger trigger m, UpdateTrigger trigger readEntity writeEntity) => TableDefinition readEntity writeEntity key -> readEntity -> writeEntity -> m ()
class UpdateTrigger trigger readEntity writeEntity
updateTriggers :: UpdateTrigger trigger readEntity writeEntity => readEntity -> writeEntity -> [trigger]
deleteTriggered :: (MonadThrow m, MonadOrville conn m, MonadTrigger trigger m, DeleteTrigger trigger readEntity) => TableDefinition readEntity writeEntity key -> readEntity -> m ()
class DeleteTrigger trigger readEntity
deleteTriggers :: DeleteTrigger trigger readEntity => readEntity -> [trigger]
class MonadTrigger trigger m | m -> trigger
runTriggers :: MonadTrigger trigger m => [trigger] -> m ()
data OrvilleTriggerT trigger conn m a
data RecordedTriggers trigger
committedTriggers :: RecordedTriggers trigger -> [trigger]
uncommittedTriggers :: RecordedTriggers trigger -> Maybe [trigger]
runOrvilleTriggerT :: (MonadIO m, MonadBaseControl IO m) => OrvilleTriggerT trigger conn m a -> Pool conn -> m (a, [trigger])
askTriggers :: MonadIO m => OrvilleTriggerT trigger conn m (RecordedTriggers trigger)
clearTriggers :: MonadIO m => OrvilleTriggerT trigger conn m ()
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance GHC.Base.Monad m => GHC.Base.Monad (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance GHC.Base.Functor m => GHC.Base.Functor (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance Control.Monad.Trans.Class.MonadTrans (Database.Orville.Trigger.OrvilleTriggerT trigger conn)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance Control.Monad.Trans.Control.MonadTransControl (Database.Orville.Trigger.OrvilleTriggerT trigger conn)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance (GHC.Base.Monad m, Control.Monad.IO.Class.MonadIO m, Database.HDBC.Types.IConnection conn, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m, Control.Monad.Catch.MonadThrow m) => Database.Orville.Internal.Monad.MonadOrville conn (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
instance Control.Monad.IO.Class.MonadIO m => Database.Orville.Trigger.MonadTrigger trigger (Database.Orville.Trigger.OrvilleTriggerT trigger conn m)
